-- Create database schema
CREATE SCHEMA IF NOT EXISTS public;

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create users table (profiles)
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    username VARCHAR(50) UNIQUE NOT NULL,
    full_name VARCHAR(100),
    avatar_url TEXT,
    bio TEXT,
    role VARCHAR(20) DEFAULT 'user' CHECK (role IN ('user', 'admin', 'moderator')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Create ideas table
CREATE TABLE public.ideas (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    author UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    summary TEXT NOT NULL,
    content TEXT NOT NULL,
    category VARCHAR(50) NOT NULL,
    tags TEXT[] DEFAULT '{}',
    cover_img TEXT,
    likes INTEGER DEFAULT 0,
    comments_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Create comments table
CREATE TABLE public.comments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    idea_id UUID NOT NULL REFERENCES public.ideas(id) ON DELETE CASCADE,
    author UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    likes INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Create idea_likes table
CREATE TABLE public.idea_likes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    idea_id UUID NOT NULL REFERENCES public.ideas(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(idea_id, user_id)
);

-- Create comment_likes table
CREATE TABLE public.comment_likes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    comment_id UUID NOT NULL REFERENCES public.comments(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(comment_id, user_id)
);

-- Create notifications table
CREATE TABLE public.notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL CHECK (type IN ('like', 'comment', 'follow', 'achievement')),
    content TEXT NOT NULL,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Create achievements table
CREATE TABLE public.achievements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT NOT NULL,
    icon_url TEXT,
    points INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Create user_achievements table
CREATE TABLE public.user_achievements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    achievement_id UUID NOT NULL REFERENCES public.achievements(id) ON DELETE CASCADE,
    unlocked_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, achievement_id)
);

-- Create indexes
CREATE INDEX idx_ideas_author ON public.ideas(author);
CREATE INDEX idx_ideas_category ON public.ideas(category);
CREATE INDEX idx_ideas_created_at ON public.ideas(created_at DESC);
CREATE INDEX idx_comments_idea_id ON public.comments(idea_id);
CREATE INDEX idx_comments_author ON public.comments(author);
CREATE INDEX idx_idea_likes_idea_id ON public.idea_likes(idea_id);
CREATE INDEX idx_idea_likes_user_id ON public.idea_likes(user_id);
CREATE INDEX idx_comment_likes_comment_id ON public.comment_likes(comment_id);
CREATE INDEX idx_comment_likes_user_id ON public.comment_likes(user_id);
CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX idx_user_achievements_user_id ON public.user_achievements(user_id);

-- Create functions
CREATE OR REPLACE FUNCTION public.increment_counter(row_id UUID, counter_name TEXT)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    new_count INTEGER;
BEGIN
    EXECUTE format('
        UPDATE public.%I 
        SET %I = %I + 1 
        WHERE id = $1 
        RETURNING %I',
        TG_TABLE_NAME, counter_name, counter_name, counter_name)
    INTO new_count
    USING row_id;
    
    RETURN new_count;
END;
$$;

-- Function to toggle idea like
CREATE OR REPLACE FUNCTION public.toggle_like(idea_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM public.idea_likes 
        WHERE idea_likes.idea_id = toggle_like.idea_id 
        AND user_id = auth.uid()
    ) THEN
        DELETE FROM public.idea_likes
        WHERE idea_likes.idea_id = toggle_like.idea_id
        AND user_id = auth.uid();
        
        UPDATE public.ideas
        SET likes = likes - 1
        WHERE id = toggle_like.idea_id;
    ELSE
        INSERT INTO public.idea_likes (idea_id, user_id)
        VALUES (toggle_like.idea_id, auth.uid());
        
        UPDATE public.ideas
        SET likes = likes + 1
        WHERE id = toggle_like.idea_id;
    END IF;
END;
$$;

-- Function to toggle comment like
CREATE OR REPLACE FUNCTION public.toggle_comment_like(comment_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM public.comment_likes 
        WHERE comment_likes.comment_id = toggle_comment_like.comment_id 
        AND user_id = auth.uid()
    ) THEN
        DELETE FROM public.comment_likes
        WHERE comment_likes.comment_id = toggle_comment_like.comment_id
        AND user_id = auth.uid();
        
        UPDATE public.comments
        SET likes = likes - 1
        WHERE id = toggle_comment_like.comment_id;
    ELSE
        INSERT INTO public.comment_likes (comment_id, user_id)
        VALUES (toggle_comment_like.comment_id, auth.uid());
        
        UPDATE public.comments
        SET likes = likes + 1
        WHERE id = toggle_comment_like.comment_id;
    END IF;
END;
$$;

-- Enable Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ideas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.idea_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comment_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_achievements ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
-- Profiles policies
CREATE POLICY "Public profiles are viewable by everyone"
ON public.profiles FOR SELECT
USING ( true );

CREATE POLICY "Users can insert their own profile"
ON public.profiles FOR INSERT
WITH CHECK ( auth.uid() = id );

CREATE POLICY "Users can update own profile"
ON public.profiles FOR UPDATE
USING ( auth.uid() = id );

-- Ideas policies
CREATE POLICY "Ideas are viewable by everyone"
ON public.ideas FOR SELECT
USING ( true );

CREATE POLICY "Authenticated users can create ideas"
ON public.ideas FOR INSERT
WITH CHECK ( auth.role() = 'authenticated' );

CREATE POLICY "Users can update own ideas"
ON public.ideas FOR UPDATE
USING ( auth.uid() = author );

CREATE POLICY "Users can delete own ideas"
ON public.ideas FOR DELETE
USING ( auth.uid() = author );

-- Comments policies
CREATE POLICY "Comments are viewable by everyone"
ON public.comments FOR SELECT
USING ( true );

CREATE POLICY "Authenticated users can create comments"
ON public.comments FOR INSERT
WITH CHECK ( auth.role() = 'authenticated' );

CREATE POLICY "Users can update own comments"
ON public.comments FOR UPDATE
USING ( auth.uid() = author );

CREATE POLICY "Users can delete own comments"
ON public.comments FOR DELETE
USING ( auth.uid() = author );

-- Likes policies
CREATE POLICY "Likes are viewable by everyone"
ON public.idea_likes FOR SELECT
USING ( true );

CREATE POLICY "Authenticated users can toggle likes"
ON public.idea_likes FOR INSERT
WITH CHECK ( auth.role() = 'authenticated' );

CREATE POLICY "Users can remove their likes"
ON public.idea_likes FOR DELETE
USING ( auth.uid() = user_id );

-- Notifications policies
CREATE POLICY "Users can view own notifications"
ON public.notifications FOR SELECT
USING ( auth.uid() = user_id );

CREATE POLICY "System can create notifications"
ON public.notifications FOR INSERT
WITH CHECK ( auth.role() = 'authenticated' );

CREATE POLICY "Users can update own notifications"
ON public.notifications FOR UPDATE
USING ( auth.uid() = user_id );

-- Achievements policies
CREATE POLICY "Achievements are viewable by everyone"
ON public.achievements FOR SELECT
USING ( true );

CREATE POLICY "Only admins can manage achievements"
ON public.achievements FOR ALL
USING ( auth.role() = 'authenticated' AND EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role = 'admin'
));

-- User achievements policies
CREATE POLICY "User achievements are viewable by everyone"
ON public.user_achievements FOR SELECT
USING ( true );

CREATE POLICY "System can create user achievements"
ON public.user_achievements FOR INSERT
WITH CHECK ( auth.role() = 'authenticated' );

-- Create triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ideas_updated_at
    BEFORE UPDATE ON public.ideas
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_comments_updated_at
    BEFORE UPDATE ON public.comments
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();